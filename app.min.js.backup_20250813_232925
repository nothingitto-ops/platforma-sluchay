// Обновлено из products.json: 2025-08-13 23:17:05
const DEFAULT_TG = 'https://t.me/stub123';
/* ===== DATA (главная) ===== */
const items = [
  {
    "images": [
      "product_2/product_2_1.jpg",
      "product_2/product_2_2.jpg",
      "product_2/product_2_3.jpg",
      "product_2/product_2_4.jpg"
    ],
    "title": "Пояс-юбка",
    "price": "3002 р.",
    "desc": "Пояс, который имеет функцию мешка",
    "meta": "Состав: 50% хлопок 50% лён",
    "link": "https://t.me/stub123",
    "status": "stock",
    "order": 1,
    "section": "home"
  },
  {
    "images": [
      "product_1/product_1_1.jpg",
      "product_1/product_1_2.jpg",
      "product_1/product_1_3.jpg",
      "product_1/product_1_4.jpg"
    ],
    "title": "Пояс цветочный",
    "price": "3000 р.",
    "desc": "Пояс, созданный совместно с nessffo, рисунок при помощи цианотипии",
    "meta": "Состав: 50% хлопок 50% лён",
    "link": "https://t.me/stub123",
    "status": "stock",
    "order": 1,
    "section": "nessffo"
  },
  {
    "images": [
      "product_3/product_3_1.jpg",
      "product_3/product_3_2.jpg",
      "product_3/product_3_3.jpg",
      "product_3/product_3_4.jpg"
    ],
    "title": "Пояс P1",
    "price": "3500 р.",
    "desc": "Пояс, который имеет функцию мешка",
    "meta": "Состав: 100% хлопок (цвет на выбор)",
    "link": "https://t.me/stub123",
    "status": "stock",
    "order": 2,
    "section": "home"
  },
  {
    "images": [
      "product_7/product_7_1.jpg",
      "product_7/product_7_2.jpg",
      "product_7/product_7_3.jpg",
      "product_7/product_7_4.jpg"
    ],
    "title": "Сумка через плечо",
    "price": "4500 р.",
    "desc": "Сумка, созданная совместно с nessffo, рисунок при помощи цианотипии",
    "meta": "Состав: 50% хлопок 50% лён",
    "link": "https://t.me/stub123",
    "status": "stock",
    "order": 2,
    "section": "nessffo"
  },
  {
    "images": [
      "product_4/product_4_1.jpg",
      "product_4/product_4_2.jpg",
      "product_4/product_4_3.jpg",
      "product_4/product_4_4.jpg",
      "product_4/product_4_5.jpg",
      "product_4/product_4_6.jpg"
    ],
    "title": "Рубашка",
    "price": "4000 р.",
    "desc": "Лёгкая рубашка со свободными рукавами",
    "meta": "Состав: 100% вареный хлопок (цвет на выбор)",
    "link": "https://t.me/stub123",
    "status": "preorder",
    "order": 3,
    "section": "home"
  },
  {
    "images": [
      "product_5/product_5_1.jpg",
      "product_5/product_5_2.jpg",
      "product_5/product_5_3.jpg",
      "product_5/product_5_4.jpg",
      "product_5/product_5_5.jpg"
    ],
    "title": "Штаны с поясом U2",
    "price": "5800 р.",
    "desc": "Свободные штаны с укороченным поясом-юбкой",
    "meta": "Состав: 100% вареный хлопок (цвет на выбор)",
    "link": "https://t.me/stub123",
    "status": "preorder",
    "order": 4,
    "section": "home"
  },
  {
    "images": [
      "product_6/product_6_1.jpg",
      "product_6/product_6_2.jpg",
      "product_6/product_6_3.jpg",
      "product_6/product_6_4.jpg",
      "product_6/product_6_5.jpg",
      "product_6/product_6_6.jpg"
    ],
    "title": "Рубашка с вышивкой",
    "price": "8000 р.",
    "desc": "Рубашка с вышивкой",
    "meta": "Состав: 100% хлопок · Деликатная стирка 30°C, после стирки рубашка может обрести эффект варёной ткани",
    "link": "https://t.me/stub123",
    "status": "preorder",
    "order": 5,
    "section": "home"
  },
  {
    "images": [
      "product_8/product_8_1.jpg",
      "product_8/product_8_2.jpg",
      "product_8/product_8_3.jpg",
      "product_8/product_8_4.jpg"
    ],
    "title": "Рубашка и шорты",
    "price": "7500 р.",
    "desc": "Рубашка и шорты",
    "meta": "Состав: 100% вареный хлопок (цвет на выбор)",
    "link": "https://t.me/stub123",
    "status": "preorder",
    "order": 6,
    "section": "home"
  },
  {
    "images": [
      "product_9/product_9_1.jpg",
      "product_9/product_9_2.jpg",
      "product_9/product_9_3.jpg"
    ],
    "title": "Платок на шею",
    "price": "1000 р.",
    "desc": "Платок серого цвета",
    "meta": "Состав: 100% жатая вискоза · Деликатная стирка 30°C",
    "link": "https://t.me/stub123",
    "status": "stock",
    "order": 7,
    "section": "home"
  },
  {
    "images": [
      "product_10/product_10_1.jpg",
      "product_10/product_10_2.jpg",
      "product_10/product_10_3.jpg"
    ],
    "title": "Штаны с поясом U1",
    "price": "6000 р.",
    "desc": "Свободные штаны с поясом-юбкой",
    "meta": "Состав: 100% вареный хлопок (цвет на выбор)",
    "link": "https://t.me/stub123",
    "status": "preorder",
    "order": 8,
    "section": "home"
  },
  {
    "images": [
      "product_11/product_11_1.jpg",
      "product_11/product_11_2.jpg",
      "product_11/product_11_3.jpg",
      "product_11/product_11_4.jpg"
    ],
    "title": "Фартук",
    "price": "3000 р.",
    "desc": "Фартук имеет карман и бретель, которая регулирует длину при помощи пуговицы",
    "meta": "Состав: 100% вареный хлопок (цвет на выбор)",
    "link": "https://t.me/stub123",
    "status": "stock",
    "order": 9,
    "section": "home"
  },
  {
    "images": [
      "product_12/product_12_1.jpg",
      "product_12/product_12_2.jpg",
      "product_12/product_12_3.jpg",
      "product_12/product_12_4.jpg"
    ],
    "title": "Платок на шею",
    "price": "1000 р.",
    "desc": "Платок молочного цвета",
    "meta": "Состав: 100% жатая вискоза · Деликатная стирка 30°C",
    "link": "https://t.me/stub123",
    "status": "stock",
    "order": 10,
    "section": "home"
  }
]; // данные из каталога

/* ===== GRID (первичная отрисовка главной — ОСТАВЛЕНО БЕЗ ИЗМЕНЕНИЙ) ===== */
const $catalog=document.getElementById('catalog');
const __initialTab = (location.hash.replace('#','')==='nessffo') ? 'nessffo' : 'home';
const ENABLE_INITIAL_HOME_RENDER = false; // отключаем, чтобы не мигала нецелевой раздел
if(ENABLE_INITIAL_HOME_RENDER && __initialTab==='home'){
  items.forEach(it=>{
    const card=document.createElement('div');
    card.className='card'+(it.placeholder?' placeholder':'');
    const imgBox=document.createElement('div');imgBox.className='card-img';
    const img=document.createElement('img');
    const _hints = folderHintsFromFirst((it.images && it.images[0])||'');
    setSrcWithFallback(img, (it.images&&it.images[0])||'img/item-placeholder.jpg', _hints);
    img.alt=it.title||''; img.draggable=false;
    img.addEventListener('dragstart', e=>e.preventDefault());
    imgBox.appendChild(img);
    card.appendChild(imgBox);
    const h3=document.createElement('h3');h3.textContent=it.title||'';card.appendChild(h3);
    const price=document.createElement('div');price.className='price';price.textContent=it.price||'';card.appendChild(price);
    if(!it.placeholder && it.status){ const st=document.createElement('div'); const cls=(it.status==='preorder')?'pre':'in'; st.className='status '+cls; st.textContent=(it.status==='preorder')?'под заказ':'в наличии'; card.appendChild(st);} 
    $catalog.appendChild(card);
    if(!it.placeholder) card.addEventListener('click',()=>openModal(it, currentTab));
  });
}

/* ===== MODАЛКА ===== */
const $modal=document.getElementById('modal');
const $viewer=document.getElementById('viewer');
const $viewerImg=document.getElementById('viewerImg');
const $thumbs=document.getElementById('thumbs');
const $zoomBtn=document.getElementById('zoomBtn');
const $mTitle=document.getElementById('mTitle');
const $mPrice=document.getElementById('mPrice');
const $mDesc=document.getElementById('mDesc');
const $mMeta=document.getElementById('mMeta');


const $carePanel=document.getElementById('carePanel');
const $mStatus=document.getElementById('mStatus');
const $mLink=document.getElementById('mLink');
const $hero=document.querySelector('.hero');
if ($hero) {
  $hero.setAttribute('decoding','async');
  $hero.setAttribute('loading','eager');
  $hero.setAttribute('fetchpriority','high');
}
const $topnav=document.querySelector('.topnav');

// Переменные для свайпов
let touchStartY = 0;
let touchStartX = 0;
let touchEndY = 0;
let touchEndX = 0;
let isSwiping = false;
let swipeThreshold = 100;
let isSwipeUp = false;
let sheetElement = null; // минимальное расстояние для свайпа

function applyNavScroll(){ 
  if($topnav) {
    if(window.scrollY>8) $topnav.classList.add('scrolled'); 
    else $topnav.classList.remove('scrolled'); 
  }
}
window.addEventListener('scroll', applyNavScroll, {passive:true});
applyNavScroll();

const SHEET_TSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vRGdW7QcHV6BgZHJnSMzXKkmsXDYZulMojN312tgvI6PK86H8dRjReYUOHI2l_aVYzLg2NIjAcir89g/pub?output=tsv&t=20250810191426&v=20250810191426&nocache=1'; // ← ваша ссылка на Google Sheets

let current=null,curIndex=0,zoomed=false, currentHints=[];
let dragging=false, startX=0, startY=0, tx=0, ty=0, moved=false;   // translate state
const SCALE=2; // коэффициент зума
const DRAG_THRESHOLD = 3; // px — чтобы клик не путался с микродвижениями

// Глобальные переменные для вкладок
let currentTab = (location.hash.replace('#','')==='nessffo') ? 'nessffo' : 'home';
let activeFilter = 'all';
let heroReady = false;

// Функции для обработки свайпов
function handleTouchStart(e) {
  if (e.touches.length === 1) {
    touchStartY = e.touches[0].clientY;
    touchStartX = e.touches[0].clientX;
    isSwiping = false;
  }
}

function handleTouchMove(e) {
  if (e.touches.length === 1 && !zoomed) {
    touchEndY = e.touches[0].clientY;
    touchEndX = e.touches[0].clientX;
    
    const deltaY = touchStartY - touchEndY;
    const deltaX = touchStartX - touchEndX;
    
    // Проверяем, что это значительный свайп (вертикальный или горизонтальный)
    if (Math.abs(deltaY) > 5 || Math.abs(deltaX) > 5) {
      isSwiping = true;
      
      // Для вертикального свайпа вверх добавляем анимацию
      if (Math.abs(deltaY) > Math.abs(deltaX) && deltaY > 0) {
        isSwipeUp = true;
        e.preventDefault();
        
        // Добавляем класс для убирания темного фейда сразу
        $modal.classList.add('swiping');
        
        // Плавное перемещение модального окна за пальцем
        if (sheetElement) {
          // Более плавное сопротивление - карточка движется естественно
          const resistance = 0.8; // 80% от движения пальца
          const maxSwipe = window.innerHeight * 0.8; // Максимальный свайп 80% от высоты экрана
          const translateY = Math.min((deltaY * resistance), maxSwipe);
          const translatePercent = (translateY / maxSwipe) * 100;
          
          sheetElement.style.transform = `translateY(-${translatePercent}%)`;
          sheetElement.style.transition = 'none'; // Без transition для мгновенного следования за пальцем
        }
      } else {
        isSwipeUp = false;
        // Предотвращаем скролл только для вертикальных свайпов
        if (Math.abs(deltaY) > Math.abs(deltaX)) {
          e.preventDefault();
        }
      }
    }
  }
}

function handleTouchEnd(e) {
  if (isSwiping && !zoomed && current) {
    const deltaY = touchStartY - touchEndY;
    const deltaX = touchStartX - touchEndX;
    
    // Убираем класс swiping
    $modal.classList.remove('swiping');
    
    // Свайп вверх для закрытия модалки - порог 35% от высоты экрана
    const screenHeight = window.innerHeight;
    const threshold = screenHeight * 0.35; // 35% от высоты экрана - стандартное значение
    
    if (deltaY > threshold && Math.abs(deltaY) > Math.abs(deltaX)) {
      // Плавное закрытие модалки
      if (sheetElement) {
        $modal.classList.add('swipe-complete'); // Мгновенно убираем фейд
        sheetElement.classList.add('swipe-complete');
        sheetElement.style.transform = 'translateY(-100%)';
        
        // Закрываем модалку после анимации
        setTimeout(() => {
          closeModal();
        }, 600);
      } else {
        closeModal();
      }
    } else if (isSwipeUp) {
      // Если свайп не достиг порога, возвращаем модалку на место плавно
      if (sheetElement) {
        sheetElement.style.transition = 'transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
        sheetElement.style.transform = 'translateY(0)';
        
        // Убираем transition после анимации
        setTimeout(() => {
          sheetElement.style.transition = 'none';
        }, 300);
      }
    }
    // Свайп влево/вправо для перелистывания фото
    else if (Math.abs(deltaX) > swipeThreshold && current.images.length > 1) {
      if (deltaX > 0) {
        // Свайп влево - следующее фото
        curIndex = (curIndex + 1) % current.images.length;
      } else {
        // Свайп вправо - предыдущее фото
        curIndex = (curIndex - 1 + current.images.length) % current.images.length;
      }
      setMain(current.images[curIndex], true);
    }
  }
  
  isSwiping = false;
  isSwipeUp = false;
}

// Добавляем обработчики свайпов к модальному окну
function addSwipeHandlers() {
  const $sheet = document.querySelector('.modal .sheet');
  if ($sheet) {
    sheetElement = $sheet; // Сохраняем ссылку на элемент
    $sheet.addEventListener('touchstart', handleTouchStart, { passive: false });
    $sheet.addEventListener('touchmove', handleTouchMove, { passive: false });
    $sheet.addEventListener('touchend', handleTouchEnd, { passive: true });
  }
}

// Удаляем обработчики свайпов
function removeSwipeHandlers() {
  const $sheet = document.querySelector('.modal .sheet');
  if ($sheet) {
    $sheet.removeEventListener('touchstart', handleTouchStart);
    $sheet.removeEventListener('touchmove', handleTouchMove);
    $sheet.removeEventListener('touchend', handleTouchEnd);
  }
}

function openModal(item, section){
  current=item;curIndex=0;zoomed=false;tx=ty=0;currentHints=folderHintsFromFirst(item.images[0]);
  $mTitle.textContent=item.title;
  
  // Форматируем цену: убираем " р." и добавляем пробелы + символ ₽
  const priceText = item.price.replace(' р.', '').replace('р', '');
  const formattedPrice = priceText.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ' ') + ' ₽';
  
  // Создаем контейнер для цены и статуса в модальном окне
  $mPrice.innerHTML = '';
  const priceContainer = document.createElement('div');
  priceContainer.className = 'modal-price-container';
  
  const priceElement = document.createElement('span');
  priceElement.className = 'price-text';
  priceElement.textContent = formattedPrice;
  priceContainer.appendChild(priceElement);
  
  // Добавляем статус справа от цены
  if (item.status) {
    const statusElement = document.createElement('span');
    const cls = (item.status === 'preorder') ? 'pre' : 'in';
    statusElement.className = 'modal-status ' + cls;
    statusElement.textContent = (item.status === 'preorder') ? 'под заказ' : 'в наличии';
    priceContainer.appendChild(statusElement);
  }
  
  $mPrice.appendChild(priceContainer);
  
  $mDesc.textContent=item.desc;
  
  // Принудительно ограничиваем описание 4 строками и убираем скролл
  // Принудительно устанавливаем высоту для 4 строк
  $mDesc.style.setProperty('-webkit-line-clamp', '4', 'important');
  $mDesc.style.setProperty('height', '6em', 'important');
  $mDesc.style.setProperty('max-height', '6em', 'important');
  $mMeta.textContent=item.meta||'';
  $mLink.href=item.link;
  // Скрываем старый элемент статуса, так как теперь он в контейнере с ценой
  $mStatus.style.display='none';
  setMain(item.images[0], true);
  renderThumbs(item.images);
  leaveZoom();
  $modal.classList.add('open');
  document.body.style.overflow='hidden';
  addSwipeHandlers(); // Добавляем обработчики свайпов при открытии модалки
}
function closeModal(){
  // Мгновенно убираем все классы анимации
  $modal.classList.remove('open', 'swipe-complete', 'swiping');
  document.body.style.overflow='';
  leaveZoom();
  removeSwipeHandlers(); // Удаляем обработчики свайпов при закрытии модалки
  
  // Сбрасываем анимацию модального окна мгновенно
  if (sheetElement) {
    sheetElement.style.transform = '';
    sheetElement.style.transition = 'none';
    sheetElement.classList.remove('swipe-complete', 'wobble');
  }
  
  // Удаляем точки-индикаторы при закрытии модалки
  const dots = document.querySelector('.image-dots');
  if (dots) dots.remove();
}
if($modal) $modal.addEventListener('click',closeModal);
const closeBtn = document.getElementById('closeBtn');
if(closeBtn) closeBtn.addEventListener('click',closeModal);

function renderThumbs(arr){
  $thumbs.innerHTML='';
  
  // Добавляем точки-индикаторы для мобильных устройств
  if (window.innerWidth <= 768 && arr.length > 1) {
    const dotsContainer = document.createElement('div');
    dotsContainer.className = 'image-dots';
    arr.forEach((_, idx) => {
      const dot = document.createElement('div');
      dot.className = `image-dot ${idx === curIndex ? 'active' : ''}`;
      dotsContainer.appendChild(dot);
    });
    $viewer.appendChild(dotsContainer);
  }
  
  arr.forEach((src,i)=>{
    const t=document.createElement('img');
    setSrcWithFallback(t, src, currentHints); t.alt='';
    t.draggable=false;
    t.addEventListener('dragstart', e=>e.preventDefault());
    if(i===curIndex)t.classList.add('active');
    t.onclick=()=>{
      curIndex=i;
      setMain(src, true);
      // Обновляем точки
      document.querySelectorAll('.image-dot').forEach((dot, idx) => {
        dot.classList.toggle('active', idx === i);
      });
    };
    $thumbs.appendChild(t);
  });
}

/* === МГНОВЕННАЯ смена кадра, без интерполяции === */
function setMain(src, snap=false){
  if(!$viewerImg || !$thumbs) return;
  leaveZoom();                 // сброс трансформаций
  if (snap) $viewerImg.style.transition = 'none'; // гарантированно без анимации
  setSrcWithFallback($viewerImg, src, currentHints);
  // активный превью
  [...$thumbs.children].forEach((el,i)=>el.classList.toggle('active',i===curIndex));
  
  // Обновляем точки-индикаторы
  document.querySelectorAll('.image-dot').forEach((dot, idx) => {
    dot.classList.toggle('active', idx === curIndex);
  });
}

/* Листание по клику по краям — работает ТОЛЬКО когда НЕ зум */
if($viewer) {
  $viewer.addEventListener('click',e=>{
    if(zoomed || moved) return; // в зуме клики игнорим, а если был драг — тоже
    const rect=$viewer.getBoundingClientRect();
    const left=(e.clientX-rect.left) < rect.width/2;
    curIndex=(curIndex+(left?-1:1)+current.images.length)%current.images.length;
    setMain(current.images[curIndex], true);
    
    // Обновляем точки при клике по краям
    document.querySelectorAll('.image-dot').forEach((dot, idx) => {
      dot.classList.toggle('active', idx === curIndex);
    });
  });
}

/* === ЗУМ ===
   — Кнопка 🔍: включает/выключает
   — Двойной клик по изображению: включает/выключает
   — Перетаскивание: только при нажатой кнопке, без «wobbling» и без drag ghost
*/
if($zoomBtn) $zoomBtn.addEventListener('click',()=> zoomed ? leaveZoom() : enterZoom());
if($viewerImg) {
  $viewerImg.addEventListener('dblclick', (e)=>{
    e.preventDefault();
    e.stopPropagation();
    if(zoomed) leaveZoom(); // вход только через кнопку; dblclick — только выход
  });
}

function enterZoom(){
  if(!$viewerImg) return;
  zoomed=true;tx=ty=0;
  $viewerImg.style.transition='none';
  $viewerImg.style.transform=`translate(0px,0px) scale(${SCALE})`;
  $viewerImg.style.cursor='grab';
}
function leaveZoom(){
  if(!$viewerImg) return;
  zoomed=false;dragging=false;tx=ty=0;
  $viewerImg.style.transition='none';
  $viewerImg.style.transform='translate(0px,0px) scale(1)';
  $viewerImg.style.cursor='default';
}

/* ——— Перетаскивание через Pointer Events (чтоб без ghost-иконок) ——— */
if($viewerImg) {
  $viewerImg.addEventListener('dragstart', e=>e.preventDefault());

  $viewerImg.addEventListener('pointerdown', e=>{
    if(!zoomed) return;
    e.preventDefault(); // не даём браузеру начинать drag-image
    $viewerImg.setPointerCapture(e.pointerId);
    dragging=true; moved=false;
    startX=e.clientX; startY=e.clientY;
    $viewerImg.style.cursor='grabbing';
  });

  $viewerImg.addEventListener('pointermove', e=>{
    if(!zoomed || !dragging) return;
    const dx=e.clientX-startX, dy=e.clientY-startY;
    if (!moved && (Math.abs(dx)>DRAG_THRESHOLD || Math.abs(dy)>DRAG_THRESHOLD)) moved=true;

    const nextX=tx+dx, nextY=ty+dy;
    const bounds=getBounds();
    const clampedX=Math.max(bounds.minX, Math.min(bounds.maxX, nextX));
    const clampedY=Math.max(bounds.minY, Math.min(bounds.maxY, nextY));
    $viewerImg.style.transform=`translate(${clampedX}px,${clampedY}px) scale(${SCALE})`;
  });

  $viewerImg.addEventListener('pointerup', e=>{
    if(!zoomed) return;
    $viewerImg.releasePointerCapture(e.pointerId);
    dragging=false;
    // фиксируем текущее смещение из transform:
    const m = /translate\(([-\d.]+)px,\s*([-\d.]+)px\)/.exec($viewerImg.style.transform);
    if(m){ tx=parseFloat(m[1]); ty=parseFloat(m[2]); }
    $viewerImg.style.cursor='grab';
  });
}

/* Границы для перетягивания в зуме */
function getBounds(){
  if(!$viewerImg || !$viewer) return {minX:0, maxX:0, minY:0, maxY:0};
  const iw=$viewerImg.naturalWidth, ih=$viewerImg.naturalHeight;
  const cw=$viewer.clientWidth, ch=$viewer.clientHeight;
  // размеры вписанной картинки при scale=1
  const imgAspect=iw/ih, boxAspect=cw/ch;
  let fittedW, fittedH;
  if(imgAspect>boxAspect){ fittedW=cw; fittedH=cw/imgAspect; }
  else { fittedH=ch; fittedW=ch*imgAspect; }

  const zw = fittedW * SCALE;
  const zh = fittedH * SCALE;
  const maxX = Math.max(0, (zw - cw)/2);
  const maxY = Math.max(0, (zh - ch)/2);
  return {minX:-maxX, maxX, minY:-maxY, maxY};
}

window.addEventListener('keydown',e=>{ if(e.key==='Escape') closeModal(); });

// Кэш для уже найденных путей к изображениям
const RESOLVED_SRC = Object.create(null);

// Построение списка кандидатов путей с учётом возможной подпапки
function folderHintsFromFirst(first){
  if(!first) return [];
  let s = String(first).trim();
  const low = s.toLowerCase();
  // если автор явно указал подпуть "folder/file.jpg" — используем его как хинт
  if (s.includes('/')) {
    const dir = s.split('/')[0].replace(/^\.\/?|^img\//,'');
    return [dir];
  }
  // иначе строим подсказки из имени первого файла
  if (low.startsWith('img/')) s = s.slice(4);
  const dot = s.lastIndexOf('.');
  const base = dot > 0 ? s.slice(0, dot) : s; // напр. shawl-1
  const lastDash = base.lastIndexOf('-');
  const prefix   = lastDash > 0 ? base.slice(0, lastDash) : base; // shawl
  // вставляем дефис перед хвостовыми цифрами, если его не было (apron1 -> apron-1)
  let dashedPrefix = prefix;
  let i = prefix.length - 1;
  while (i >= 0) { const code = prefix.charCodeAt(i); if (code < 48 || code > 57) break; i--; }
  if (i < prefix.length - 1 && prefix[i] !== '-') {
    dashedPrefix = prefix.slice(0, i + 1) + '-' + prefix.slice(i + 1);
  }
  return Array.from(new Set([dashedPrefix, prefix, base].filter(Boolean)));
}

// Делает несколько вариантов пути и подставляет первый удачный.
function candidatesFor(src, hintFolders){
  if(!src) return ['img/item-placeholder.jpg'];
  let s = String(src);
  const low = s.toLowerCase();
  // абсолютные URL — как есть
  if (low.startsWith('http://') || low.startsWith('https://')) return [s];
  // убрать возможный префикс img/
  if (low.startsWith('img/')) s = s.slice(4);
  else if (low.startsWith('./img/')) s = s.slice(6);
  else if (low.startsWith('/img/')) s = s.slice(5);
  // если уже указан подпуть вида folder/file.jpg — пробуем как есть (с префиксом img/)
  if (s.includes('/')) return ['img/' + s];

  // имя файла без расширения
  const dot = s.lastIndexOf('.');
  const base = dot > 0 ? s.slice(0, dot) : s;            // напр. apron1-1
  const lastDash = base.lastIndexOf('-');
  const prefix   = lastDash > 0 ? base.slice(0, lastDash) : base; // напр. apron1

  // добавить дефис перед хвостовыми цифрами: apron1 -> apron-1
  let dashedPrefix = prefix;
  let i = prefix.length - 1;
  while (i >= 0) { const code = prefix.charCodeAt(i); if (code < 48 || code > 57) break; i--; }
  if (i < prefix.length - 1 && prefix[i] !== '-') {
    dashedPrefix = prefix.slice(0, i + 1) + '-' + prefix.slice(i + 1);
  }

  // Подсказки подпапок: сначала более короткие (shawl-2 раньше shawl-2-1)
  const hints = Array.isArray(hintFolders)
    ? Array.from(new Set(hintFolders)).sort((a,b)=>{
        const ad = a.includes('-'), bd = b.includes('-');
        if(ad && !bd) return -1; // папки с дефисом приоритетнее
        if(bd && !ad) return 1;
        return a.length - b.length; // затем по длине — короткие раньше
      })
    : [];

  const list = [
    // 0) приоритет — папки из подсказок (от коротких к длинным)
    ...hints.map(h => `img/${h}/${s}`),
    // 1) папка = часть до последнего дефиса (belt-skirt-1/belt-skirt-1-1.jpg)
    `img/${prefix}/${s}`,
    // 2) часть + дефис перед цифрами (apron-1/apron1-1.jpg)
    `img/${dashedPrefix}/${s}`,
    // 3) папка = полное имя без расширения (shawl-1/shawl-1.jpg)
    `img/${base}/${s}`,
    // 4) корень img
    `img/${s}`
  ];
  return Array.from(new Set(list));
}

function setSrcWithFallback(img, src, hintFolders){
  // Быстрый путь: уже знаем рабочий URL — не дёргаем сеть лишний раз
  if (RESOLVED_SRC[src]) {
    img.onerror = null;
    img.src = RESOLVED_SRC[src];
    return;
  }

  // Если есть явный хинт папки (берём самый первый) — пробуем СРАЗУ его,
  // чтобы не было 404 в консоли при ховере.
  let firstTry = '';
  if (Array.isArray(hintFolders) && hintFolders.length) {
    const s = String(src);
    const low = s.toLowerCase();
    if (!low.startsWith('http://') && !low.startsWith('https://')) {
      let file = s;
      if (low.startsWith('img/')) file = s.slice(4);
      else if (low.startsWith('./img/')) file = s.slice(6);
      else if (low.startsWith('/img/')) file = s.slice(5);
      if (!file.includes('/')) {
        firstTry = `img/${hintFolders[0]}/${file}`; // «фиксированная» папка от первого кадра
      }
    }
  }

  const arr = [];
  if (firstTry) arr.push(firstTry);            // <- приоритетно, обычно этого достаточно
  arr.push(...candidatesFor(src, hintFolders)); // остальное — как резерв
  arr.push('img/item-placeholder.jpg');

  let i = 0;
  const onLoad = () => { RESOLVED_SRC[src] = img.currentSrc || img.src; };
  img.addEventListener('load', onLoad, { once: true });

  const next = () => {
    if (i >= arr.length) { img.onerror = null; return; }
    const url = arr[i++];
    img.onerror = next;                 // при 404 пробуем следующий
    img.src = url;
  };
  next();
}

// Функция для установки баннера в зависимости от вкладки
function setHero(tab){
  if(!$hero) return;
  const next = (tab==='home') ? 'img/bannerh.jpg' : 'img/banner.jpg';
  // первый показ — слушаем load ДО установки src, чтобы не пропустить кешированный ответ
  if(!heroReady){
    const onFirstLoad = ()=>{
      $hero.style.visibility='visible';
      $hero.style.opacity='1';
      $hero.style.transform='translateX(0)';
      heroReady = true;
      $hero.removeEventListener('load', onFirstLoad);
    };
    $hero.addEventListener('load', onFirstLoad);
    if($hero.getAttribute('src')!==next) $hero.src = next;
    return;
  }
  if($hero.getAttribute('src')===next) return;

  const handleTransitionEnd = (e)=>{
    if(e.propertyName!=='opacity') return;
    $hero.removeEventListener('transitionend', handleTransitionEnd);
    const onLoad = () => {
      requestAnimationFrame(()=>{
        $hero.style.opacity='1';
        $hero.style.transform='translateX(0)';
      });
      $hero.removeEventListener('load', onLoad);
    };
    $hero.addEventListener('load', onLoad);
    $hero.src = next;
  };

  $hero.addEventListener('transitionend', handleTransitionEnd, {once:true});
  requestAnimationFrame(()=>{
    $hero.style.opacity='0';
    $hero.style.transform='translateX(-6px)';
  });
}

// Функция для рендера коллекции товаров
function renderCollection(arr, instant=false){
  if(!$catalog) return;
  const src = arr.filter(it => !it.placeholder && (activeFilter==='all' ? true : (it.status||'stock')===activeFilter))
    .sort((a, b) => (a.order || 999) - (b.order || 999));

  closeModal();
  
  // Добавляем плавные переходы для устранения мерцания
  if(!instant){ 
    $catalog.style.transition = 'opacity 0.4s ease-out, transform 0.4s ease-out';
    $catalog.style.opacity='0'; 
    $catalog.style.visibility='hidden';
    $catalog.style.transform = 'translateY(10px)'; // Небольшое смещение для более плавного эффекта
  }
  $catalog.innerHTML='';

  const realCount = (activeFilter==='all')
    ? arr.filter(it=>!it.placeholder).length
    : arr.filter(it=>!it.placeholder && (it.status||'stock')===activeFilter).length;

  if(realCount===0){
    const empty=document.createElement('div');
    empty.className='empty';
    empty.textContent='По выбранному фильтру пока ничего нет';
    $catalog.appendChild(empty);
  }

  src.forEach(it=>{
    const hints = folderHintsFromFirst(it.images[0]);
    const card=document.createElement('div');
    card.className='card'+(it.placeholder?' placeholder':'');
    const imgBox=document.createElement('div');imgBox.className='card-img';
    const img=document.createElement('img');
    setSrcWithFallback(img, it.images[0], hints); img.alt=it.title; img.draggable=false;
    img.addEventListener('dragstart', e=>e.preventDefault());
    imgBox.appendChild(img);
    card.appendChild(imgBox);
    const h3=document.createElement('h3');h3.textContent=it.title;card.appendChild(h3);
    // Форматируем цену для каталога
    const priceText = it.price.replace(' р.', '').replace('р', '');
    const formattedPrice = priceText.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ' ') + ' ₽';
    const price=document.createElement('div');price.className='price';price.textContent=formattedPrice;card.appendChild(price);
    if(!it.placeholder && it.status){ const st=document.createElement('div'); const cls=(it.status==='preorder')?'pre':'in'; st.className='status '+cls; st.textContent=(it.status==='preorder')?'под заказ':'в наличии'; card.appendChild(st);} 
    $catalog.appendChild(card);

    if(!it.placeholder){
      card.addEventListener('click',()=>openModal(it, currentTab));
    }
  });
}

// Функция для рендера активной вкладки
function renderActive(instant=false){
  if(!$catalog) return;
  const arr = (currentTab === 'home') ? items.filter(item => item.section === 'home') : items.filter(item => item.section === 'nessffo');
  console.log('renderActive вызвана:', {currentTab, itemsCount: items.length, filteredCount: arr.length});
  
  // Управляем кнопкой и панелью руководства
  const $careBtn = document.getElementById('careBtn');
  const showInNessffo = currentTab === 'nessffo';
  
  // Устанавливаем data-section для правильных стилей фильтров
  document.body.setAttribute('data-section', currentTab);
  
  if($careBtn){
    $careBtn.style.display = showInNessffo ? 'flex' : 'none';
  }
  
  if($carePanel){
    // Определяем, мобильное ли устройство
    const isMobile = window.innerWidth <= 768;
    
    if(showInNessffo){
      if(isMobile){
        // На мобильных показываем памятку автоматически
        $carePanel.style.display = 'block';
      } else {
        // На десктопе скрываем, показываем только по клику на кнопку
        $carePanel.style.display = 'none';
      }
    } else {
      // В разделе home скрываем везде
      $carePanel.style.display = 'none';
    }
    
    // Добавляем обработчик клика для кнопки (только на десктопе)
    if(showInNessffo && !isMobile && $careBtn && !$careBtn.hasAttribute('data-click-added')){
      $careBtn.setAttribute('data-click-added', 'true');
      $careBtn.addEventListener('click', function() {
        $carePanel.style.display = $carePanel.style.display === 'none' ? 'block' : 'none';
        $carePanel.classList.remove('collapsed');
      });
    }
    
    // Добавляем обработчик клика для сворачивания памятки
    if(showInNessffo && !$carePanel.hasAttribute('data-click-added')){
      $carePanel.setAttribute('data-click-added', 'true');
      $carePanel.addEventListener('click', function(e) {
        // Сворачиваем/разворачиваем при клике на заголовок или саму панель, но не на элементы списка
        if(e.target.tagName === 'H4' || e.target.closest('h4') || (e.target === this && !e.target.closest('ul')) ){
          $carePanel.classList.toggle('collapsed');
        }
      });
    }
  }
  
  renderCollection(arr, instant);
  // показать сетку (если до этого был скелетон)
  $catalog.style.display = 'grid';
  // Не перезаписываем visibility и opacity, если это не instant рендер
  if(instant) {
    $catalog.style.visibility = 'visible';
    $catalog.style.opacity = '1';
  }
  // обновить баннер для вкладки
  setHero(currentTab);
}

// Инициализация вкладок и фильтров
(function tabs(){
  const tabs=document.querySelectorAll('.topnav .tab');
  const filterBtns = document.querySelectorAll('#filters .fbtn');
  const filterByTab = { home: 'all', nessffo: 'all' }; // дефолт на вкладку

  function setFilter(f){
    activeFilter=f;
    filterByTab[currentTab]=f;
    filterBtns.forEach(b=>b.classList.toggle('active', b.dataset.filter===f));
  }

  function activate(tab){
    tabs.forEach(b=>b.classList.toggle('active', b.dataset.tab===tab));
  }

  // Обработчики для вкладок
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      if(tab.classList.contains('active')) return;
      currentTab = tab.dataset.tab;
      activate(currentTab);
      setFilter(filterByTab[currentTab]);
      renderActive(true);
    });
  });

  // Обработчики для фильтров
  filterBtns.forEach(btn => {
    btn.addEventListener('click', () => {
      if(btn.classList.contains('active')) return;
      setFilter(btn.dataset.filter);
      renderActive(true);
    });
  });

  // Инициализация
  activate(currentTab);
  setFilter(filterByTab[currentTab]);
  renderActive(true);
})();

// Инициализация каталога при загрузке страницы
document.addEventListener('DOMContentLoaded', function() {
  console.log('DOM загружен, товаров в массиве:', items.length);
  if($catalog) {
    $catalog.style.display = 'grid';
    $catalog.style.visibility = 'visible';
    $catalog.style.opacity = '1';
    // Принудительно вызываем рендер
    renderActive(true);
  }
});

