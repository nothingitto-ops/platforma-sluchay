// Обновлено из products.json: 2025-08-14 01:15:20

// ===== ФУНКЦИОНАЛ ПЕРЕКЛЮЧЕНИЯ ИЗОБРАЖЕНИЙ ПРИ НАВЕДЕНИИ КУРСОРА =====
// Добавлен в функции renderCollection() в строках ~1108-1160
// 
// Как это работает:
// 1. При наведении курсора на карточку (mouseenter/mouseover) устанавливается флаг isHovering = true
// 2. При движении курсора (mousemove) вычисляется позиция курсора относительно карточки
// 3. На основе позиции курсора выбирается соответствующее изображение из массива it.images
// 4. Изображение переключается через функцию applyIdx() с помощью setSrcWithFallback()
// 5. При уходе курсора (mouseout/mouseleave) возвращается к первому изображению (индекс 0)
// 
// Ключевые переменные:
// - isHovering: флаг наведения курсора
// - hoverRaf: requestAnimationFrame для оптимизации производительности
// - currentHoverIndex: текущий индекс изображения
// - applyIdx(): функция переключения изображения
//
// Если нужно починить:
// 1. Найти функцию renderCollection() (строка ~1038)
// 2. Найти блок с обработчиками событий (строки ~1108-1160)
// 3. Проверить обработчики: mouseenter, mousemove, mouseover, mouseout, mouseleave
// 4. Убедиться что функция applyIdx() правильно вызывает setSrcWithFallback()
// ========================================================================
const DEFAULT_TG = 'https://t.me/stub123';
/* ===== DATA (главная) ===== */
const items = [
  {
    "images": [
      "product_2/product_2_1.jpg",
      "product_2/product_2_2.jpg",
      "product_2/product_2_3.jpg",
      "product_2/product_2_4.jpg"
    ],
    "title": "Пояс-юбка",
    "price": "3000 р.",
    "desc": "Пояс, который имеет функцию мешка",
    "meta": "Состав: 50% хлопок 50% лён",
    "link": "https://t.me/stub123",
    "status": "stock",
    "order": 1,
    "section": "home"
  },
  {
    "images": [
      "product_1/product_1_1.jpg",
      "product_1/product_1_2.jpg",
      "product_1/product_1_3.jpg",
      "product_1/product_1_4.jpg"
    ],
    "title": "Пояс цветочный",
    "price": "3000 р.",
    "desc": "Пояс, созданный совместно с nessffo, рисунок при помощи цианотипии",
    "meta": "Состав: 50% хлопок 50% лён",
    "link": "https://t.me/stub123",
    "status": "stock",
    "order": 1,
    "section": "nessffo"
  },
  {
    "images": [
      "product_3/product_3_1.jpg",
      "product_3/product_3_2.jpg",
      "product_3/product_3_3.jpg",
      "product_3/product_3_4.jpg"
    ],
    "title": "Пояс P1",
    "price": "3500 р.",
    "desc": "Пояс, который имеет функцию мешка",
    "meta": "Состав: 100% хлопок (цвет на выбор)",
    "link": "https://t.me/stub123",
    "status": "stock",
    "order": 2,
    "section": "home"
  },
  {
    "images": [
      "product_7/product_7_1.jpg",
      "product_7/product_7_2.jpg",
      "product_7/product_7_3.jpg",
      "product_7/product_7_4.jpg"
    ],
    "title": "Сумка через плечо",
    "price": "4500 р.",
    "desc": "Сумка, созданная совместно с nessffo, рисунок при помощи цианотипии",
    "meta": "Состав: 50% хлопок 50% лён",
    "link": "https://t.me/stub123",
    "status": "stock",
    "order": 2,
    "section": "nessffo"
  },
  {
    "images": [
      "product_4/product_4_1.jpg",
      "product_4/product_4_2.jpg",
      "product_4/product_4_3.jpg",
      "product_4/product_4_4.jpg",
      "product_4/product_4_5.jpg",
      "product_4/product_4_6.jpg"
    ],
    "title": "Рубашка",
    "price": "4000 р.",
    "desc": "Лёгкая рубашка со свободными рукавами",
    "meta": "Состав: 100% вареный хлопок (цвет на выбор)",
    "link": "https://t.me/stub123",
    "status": "preorder",
    "order": 3,
    "section": "home"
  },
  {
    "images": [
      "product_5/product_5_1.jpg",
      "product_5/product_5_2.jpg",
      "product_5/product_5_3.jpg",
      "product_5/product_5_4.jpg",
      "product_5/product_5_5.jpg"
    ],
    "title": "Штаны с поясом U2",
    "price": "5800 р.",
    "desc": "Свободные штаны с укороченным поясом-юбкой",
    "meta": "Состав: 100% вареный хлопок (цвет на выбор)",
    "link": "https://t.me/stub123",
    "status": "preorder",
    "order": 4,
    "section": "home"
  },
  {
    "images": [
      "product_6/product_6_1.jpg",
      "product_6/product_6_2.jpg",
      "product_6/product_6_3.jpg",
      "product_6/product_6_4.jpg",
      "product_6/product_6_5.jpg",
      "product_6/product_6_6.jpg"
    ],
    "title": "Рубашка с вышивкой",
    "price": "8000 р.",
    "desc": "Рубашка с вышивкой",
    "meta": "Состав: 100% хлопок · Деликатная стирка 30°C, после стирки рубашка может обрести эффект варёной ткани",
    "link": "https://t.me/stub123",
    "status": "preorder",
    "order": 5,
    "section": "home"
  },
  {
    "images": [
      "product_8/product_8_1.jpg",
      "product_8/product_8_2.jpg",
      "product_8/product_8_3.jpg",
      "product_8/product_8_4.jpg"
    ],
    "title": "Рубашка и шорты",
    "price": "7500 р.",
    "desc": "Рубашка и шорты",
    "meta": "Состав: 100% вареный хлопок (цвет на выбор)",
    "link": "https://t.me/stub123",
    "status": "preorder",
    "order": 6,
    "section": "home"
  },
  {
    "images": [
      "product_9/product_9_1.jpg",
      "product_9/product_9_2.jpg",
      "product_9/product_9_3.jpg"
    ],
    "title": "Платок на шею",
    "price": "1000 р.",
    "desc": "Платок серого цвета",
    "meta": "Состав: 100% жатая вискоза · Деликатная стирка 30°C",
    "link": "https://t.me/stub123",
    "status": "stock",
    "order": 7,
    "section": "home"
  },
  {
    "images": [
      "product_10/product_10_1.jpg",
      "product_10/product_10_2.jpg",
      "product_10/product_10_3.jpg"
    ],
    "title": "Штаны с поясом U1",
    "price": "6000 р.",
    "desc": "Свободные штаны с поясом-юбкой",
    "meta": "Состав: 100% вареный хлопок (цвет на выбор)",
    "link": "https://t.me/stub123",
    "status": "preorder",
    "order": 8,
    "section": "home"
  },
  {
    "images": [
      "product_11/product_11_1.jpg",
      "product_11/product_11_2.jpg",
      "product_11/product_11_3.jpg",
      "product_11/product_11_4.jpg"
    ],
    "title": "Фартук",
    "price": "3000 р.",
    "desc": "Фартук имеет карман и бретель, которая регулирует длину при помощи пуговицы",
    "meta": "Состав: 100% вареный хлопок (цвет на выбор)",
    "link": "https://t.me/stub123",
    "status": "stock",
    "order": 9,
    "section": "home"
  },
  {
    "images": [
      "product_12/product_12_1.jpg",
      "product_12/product_12_2.jpg",
      "product_12/product_12_3.jpg",
      "product_12/product_12_4.jpg"
    ],
    "title": "Платок на шею",
    "price": "1000 р.",
    "desc": "Платок молочного цвета",
    "meta": "Состав: 100% жатая вискоза · Деликатная стирка 30°C",
    "link": "https://t.me/stub123",
    "status": "stock",
    "order": 10,
    "section": "home"
  }
]; // данные из каталога

/* ===== GRID (первичная отрисовка главной — ОСТАВЛЕНО БЕЗ ИЗМЕНЕНИЙ) ===== */
const $catalog=document.getElementById('catalog');
const __initialTab = (location.hash.replace('#','')==='nessffo') ? 'nessffo' : 'home';
const ENABLE_INITIAL_HOME_RENDER = false; // отключаем, чтобы не мигала нецелевой раздел
if(ENABLE_INITIAL_HOME_RENDER && __initialTab==='home'){
  items.forEach(it=>{
    const card=document.createElement('div');
    card.className='card'+(it.placeholder?' placeholder':'');
    const imgBox=document.createElement('div');imgBox.className='card-img';
    const img=document.createElement('img');
    const _hints = folderHintsFromFirst((it.images && it.images[0])||'');
    setSrcWithFallback(img, (it.images&&it.images[0])||'img/item-placeholder.jpg', _hints);
    img.alt=it.title||''; img.draggable=false;
    img.addEventListener('dragstart', e=>e.preventDefault());
    imgBox.appendChild(img);
    card.appendChild(imgBox);
    const h3=document.createElement('h3');h3.textContent=it.title||'';card.appendChild(h3);
    const price=document.createElement('div');price.className='price';price.textContent=it.price||'';card.appendChild(price);
    if(!it.placeholder && it.status){ 
      const st=document.createElement('div'); 
      const cls=(it.status==='preorder')?'pre':'in'; 
      st.className='status '+cls; 
      st.textContent=(it.status==='preorder')?'под заказ':'в наличии';
      // Добавляем стили для статуса в карточках
      st.style.padding = '2px 6px';
      st.style.borderRadius = '4px';
      st.style.fontSize = '12px';
      st.style.fontWeight = '500';
      st.style.color = (it.status==='preorder') ? '#92400e' : '#065f46';
      st.style.backgroundColor = (it.status==='preorder') ? '#fef3c7' : '#f0fdf4';
      st.style.opacity = '0.8';
      st.style.border = 'none';
      card.appendChild(st);
    } 
    $catalog.appendChild(card);
    if(!it.placeholder) card.addEventListener('click',()=>openModal(it, currentTab));
  });
}

/* ===== MODАЛКА ===== */
const $modal=document.getElementById('modal');
const $viewer=document.getElementById('viewer');
const $viewerImg=document.getElementById('viewerImg');
const $thumbs=document.getElementById('thumbs');
const $zoomBtn=document.getElementById('zoomBtn');
const $mTitle=document.getElementById('mTitle');
const $mPrice=document.getElementById('mPrice');
const $mDesc=document.getElementById('mDesc');
const $mMeta=document.getElementById('mMeta');


const $carePanel=document.getElementById('carePanel');
const $mStatus=document.getElementById('mStatus');
const $mLink=document.getElementById('mLink');
const $hero=document.querySelector('.hero');
if ($hero) {
  $hero.setAttribute('decoding','async');
  $hero.setAttribute('loading','eager');
  $hero.setAttribute('fetchpriority','high');
}
const $topnav=document.querySelector('.topnav');

// Переменные для свайпов
let touchStartY = 0;
let touchStartX = 0;
let touchEndY = 0;
let touchEndX = 0;
let isSwiping = false;
let swipeThreshold = 100;
let isSwipeUp = false;
let sheetElement = null; // минимальное расстояние для свайпа

function applyNavScroll(){ 
  if($topnav) {
    if(window.scrollY>8) $topnav.classList.add('scrolled'); 
    else $topnav.classList.remove('scrolled'); 
  }
}
window.addEventListener('scroll', applyNavScroll, {passive:true});
applyNavScroll();

const SHEET_TSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vRGdW7QcHV6BgZHJnSMzXKkmsXDYZulMojN312tgvI6PK86H8dRjReYUOHI2l_aVYzLg2NIjAcir89g/pub?output=tsv&t=20250810191426&v=20250810191426&nocache=1'; // ← ваша ссылка на Google Sheets

let current=null,curIndex=0,zoomed=false, currentHints=[];
let dragging=false, startX=0, startY=0, tx=0, ty=0, moved=false;   // translate state
const SCALE=2; // коэффициент зума
const DRAG_THRESHOLD = 3; // px — чтобы клик не путался с микродвижениями

// Глобальные переменные для вкладок
let currentTab = (location.hash.replace('#','')==='nessffo') ? 'nessffo' : 'home';
let activeFilter = 'all';
let heroReady = false;

// Функции для обработки свайпов
function handleTouchStart(e) {
  if (e.touches.length === 1) {
    touchStartY = e.touches[0].clientY;
    touchStartX = e.touches[0].clientX;
    isSwiping = false;
  }
}

function handleTouchMove(e) {
  if (e.touches.length === 1 && !zoomed) {
    touchEndY = e.touches[0].clientY;
    touchEndX = e.touches[0].clientX;
    
    const deltaY = touchStartY - touchEndY;
    const deltaX = touchStartX - touchEndX;
    
    // Проверяем, что это значительный свайп (вертикальный или горизонтальный)
    if (Math.abs(deltaY) > 5 || Math.abs(deltaX) > 5) {
      isSwiping = true;
      
      // Для вертикального свайпа вверх добавляем анимацию
      if (Math.abs(deltaY) > Math.abs(deltaX) && deltaY > 0) {
        isSwipeUp = true;
        e.preventDefault();
        
        // Добавляем класс для убирания темного фейда сразу
        $modal.classList.add('swiping');
        
        // Плавное перемещение модального окна за пальцем
        if (sheetElement) {
          // Более плавное сопротивление - карточка движется естественно
          const resistance = 0.8; // 80% от движения пальца
          const maxSwipe = window.innerHeight * 0.8; // Максимальный свайп 80% от высоты экрана
          const translateY = Math.min((deltaY * resistance), maxSwipe);
          const translatePercent = (translateY / maxSwipe) * 100;
          
          sheetElement.style.transform = `translateY(-${translatePercent}%)`;
          sheetElement.style.transition = 'none'; // Без transition для мгновенного следования за пальцем
        }
      } else {
        isSwipeUp = false;
        // Предотвращаем скролл только для вертикальных свайпов
        if (Math.abs(deltaY) > Math.abs(deltaX)) {
          e.preventDefault();
        }
      }
    }
  }
}

function handleTouchEnd(e) {
  if (isSwiping && !zoomed && current) {
    const deltaY = touchStartY - touchEndY;
    const deltaX = touchStartX - touchEndX;
    
    // Убираем класс swiping
    $modal.classList.remove('swiping');
    
    // Свайп вверх для закрытия модалки - порог 35% от высоты экрана
    const screenHeight = window.innerHeight;
    const threshold = screenHeight * 0.35; // 35% от высоты экрана - стандартное значение
    
    if (deltaY > threshold && Math.abs(deltaY) > Math.abs(deltaX)) {
      // Плавное закрытие модалки
      if (sheetElement) {
        $modal.classList.add('swipe-complete'); // Мгновенно убираем фейд
        sheetElement.classList.add('swipe-complete');
        sheetElement.style.transform = 'translateY(-100%)';
        
        // Закрываем модалку после анимации
        setTimeout(() => {
          closeModal();
        }, 600);
      } else {
        closeModal();
      }
    } else if (isSwipeUp) {
      // Если свайп не достиг порога, возвращаем модалку на место плавно
      if (sheetElement) {
        sheetElement.style.transition = 'transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
        sheetElement.style.transform = 'translateY(0)';
        
        // Убираем transition после анимации
        setTimeout(() => {
          sheetElement.style.transition = 'none';
        }, 300);
      }
    }
    // Свайп влево/вправо для перелистывания фото
    else if (Math.abs(deltaX) > swipeThreshold && current.images.length > 1) {
      if (deltaX > 0) {
        // Свайп влево - следующее фото
        curIndex = (curIndex + 1) % current.images.length;
      } else {
        // Свайп вправо - предыдущее фото
        curIndex = (curIndex - 1 + current.images.length) % current.images.length;
      }
      setMain(current.images[curIndex], true);
    }
  }
  
  isSwiping = false;
  isSwipeUp = false;
}

// Добавляем обработчики свайпов к модальному окну
function addSwipeHandlers() {
  const $sheet = document.querySelector('.modal .sheet');
  if ($sheet) {
    sheetElement = $sheet; // Сохраняем ссылку на элемент
    $sheet.addEventListener('touchstart', handleTouchStart, { passive: false });
    $sheet.addEventListener('touchmove', handleTouchMove, { passive: false });
    $sheet.addEventListener('touchend', handleTouchEnd, { passive: true });
  }
}

// Удаляем обработчики свайпов
function removeSwipeHandlers() {
  const $sheet = document.querySelector('.modal .sheet');
  if ($sheet) {
    $sheet.removeEventListener('touchstart', handleTouchStart);
    $sheet.removeEventListener('touchmove', handleTouchMove);
    $sheet.removeEventListener('touchend', handleTouchEnd);
  }
}

function openModal(item, section){
  console.log('openModal вызвана, ширина экрана:', window.innerWidth);
  console.log('Товар:', item.title, 'секция:', section);
  console.log('Элемент модального окна:', $modal);
  
  // Проверяем, мобильное ли устройство
  if (window.innerWidth <= 768) {
    console.log('Мобильное устройство - открываем полноэкранный просмотр');
    openFullscreenViewer(item, section);
  } else {
    console.log('Десктоп - открываем десктопную модалку');
    openDesktopModal(item, section);
  }
}

function openDesktopModal(item, section){
  console.log('openDesktopModal вызвана!');
  console.log('Элементы модального окна:', {
    modal: $modal,
    title: $mTitle,
    price: $mPrice,
    desc: $mDesc
  });
  current=item;curIndex=0;zoomed=false;moved=false;tx=ty=0;currentHints=folderHintsFromFirst(item.images[0]);
  if ($mTitle) $mTitle.textContent=item.title;
  
  // Форматируем цену: убираем " р." и добавляем пробелы + символ ₽
  const priceText = item.price.replace(' р.', '').replace('р', '');
  const formattedPrice = priceText.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ' ') + ' ₽';
  
  // Создаем контейнер для цены и статуса в модальном окне
  if ($mPrice) {
    $mPrice.innerHTML = '';
    const priceContainer = document.createElement('div');
    priceContainer.className = 'modal-price-container';
    
    // Создаем один элемент для цены с символом рубля
    const priceElement = document.createElement('span');
    priceElement.className = 'price-text';
    priceElement.innerHTML = formattedPrice; // Используем innerHTML чтобы символ рубля не разбивался
    priceContainer.appendChild(priceElement);
  

  
  // Добавляем статус прямо в контейнер с ценой (без отдельного div)
  if (item.status) {
    const statusText = document.createElement('span');
    const statusLabel = (item.status === 'preorder') ? 'под заказ' : 'в наличии';
    statusText.textContent = ' ' + statusLabel;
    statusText.style.marginLeft = '8px';
    statusText.style.padding = '2px 6px';
    statusText.style.borderRadius = '4px';
    statusText.style.fontSize = '12px';
    statusText.style.fontWeight = '500';
    statusText.style.color = item.status === 'preorder' ? '#92400e' : '#065f46';
    statusText.style.backgroundColor = item.status === 'preorder' ? '#fef3c7' : '#f0fdf4';
    statusText.style.opacity = '0.8';
    statusText.style.border = 'none !important';
    statusText.style.outline = 'none !important';
    statusText.style.boxShadow = 'none !important';
    statusText.style.borderWidth = '0 !important';
    statusText.style.borderStyle = 'none !important';
    statusText.style.borderColor = 'transparent !important';
    statusText.style.verticalAlign = 'middle';
    statusText.style.display = 'inline-block';
    priceElement.appendChild(statusText);
  }
  
  $mPrice.appendChild(priceContainer);
  }
  
  if ($mDesc) {
    $mDesc.textContent=item.desc;
    
    // Убираем ограничения описания - показываем весь текст
    $mDesc.style.setProperty('display', 'block', 'important');
    $mDesc.style.setProperty('overflow', 'visible', 'important');
    $mDesc.style.setProperty('height', 'auto', 'important');
    $mDesc.style.setProperty('max-height', 'none', 'important');
  }
  if ($mMeta) $mMeta.textContent=item.meta||'';
  if ($mLink) $mLink.href=item.link;
  // Скрываем старый элемент статуса, так как теперь он в контейнере с ценой
  if ($mStatus) {
    $mStatus.style.display='none';
  }
  setMain(item.images[0], true);
  renderThumbs(item.images);
  leaveZoom();
  if ($modal) {
    $modal.classList.add('open');
  }
  document.body.style.overflow='hidden';
  addSwipeHandlers(); // Добавляем обработчики свайпов при открытии модалки
}

function openFullscreenViewer(item, section){
  console.log('openFullscreenViewer вызвана для товара:', item.title);
  console.log('Изображения товара:', item.images);
  console.log('openFullscreenViewer вызвана!');
  
  current = item;
  curIndex = 0; // Сбрасываем индекс к первому изображению
  zoomed = false;
  moved = false;
  tx = ty = 0;
  currentHints = folderHintsFromFirst(item.images[0]);
  
  // Заполняем информацию о товаре
  const fullscreenTitle = document.getElementById('fullscreenTitle');
  if (fullscreenTitle) {
    fullscreenTitle.textContent = item.title;
    console.log('Заголовок установлен:', item.title);
  } else {
    console.error('Элемент fullscreenTitle не найден!');
  }
  
  // Форматируем цену
  const priceText = item.price.replace(' р.', '').replace('р', '');
  const formattedPrice = priceText.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ' ') + ' ₽';
  const priceElement = document.querySelector('#fullscreenPrice .fullscreen-price-text');
  if (priceElement) {
    priceElement.innerHTML = formattedPrice; // Используем innerHTML чтобы символ рубля не разбивался
    console.log('Цена установлена:', formattedPrice);
    

  } else {
    console.error('Элемент цены не найден!');
  }
  
  // Добавляем статус прямо в контейнер с ценой в полноэкранном просмотре
  if (item.status) {
    const statusText = document.createElement('span');
    const statusLabel = (item.status === 'preorder') ? 'под заказ' : 'в наличии';
    statusText.textContent = ' ' + statusLabel;
    statusText.style.marginLeft = '8px';
    statusText.style.padding = '2px 6px';
    statusText.style.borderRadius = '4px';
    statusText.style.fontSize = '12px';
    statusText.style.fontWeight = '500';
    statusText.style.color = item.status === 'preorder' ? '#92400e' : '#065f46';
    statusText.style.backgroundColor = item.status === 'preorder' ? '#fef3c7' : '#f0fdf4';
    statusText.style.opacity = '0.8';
    statusText.style.border = 'none !important';
    statusText.style.outline = 'none !important';
    statusText.style.boxShadow = 'none !important';
    statusText.style.borderWidth = '0 !important';
    statusText.style.borderStyle = 'none !important';
    statusText.style.borderColor = 'transparent !important';
    statusText.style.verticalAlign = 'middle';
    statusText.style.display = 'inline-block';
    priceElement.appendChild(statusText);
  }
  

  
  const fullscreenDesc = document.getElementById('fullscreenDesc');
  if (fullscreenDesc) {
    fullscreenDesc.textContent = item.desc;
    // Убираем ограничения описания в полноэкранном просмотре
    fullscreenDesc.style.setProperty('display', 'block', 'important');
    fullscreenDesc.style.setProperty('overflow', 'visible', 'important');
    fullscreenDesc.style.setProperty('height', 'auto', 'important');
    fullscreenDesc.style.setProperty('max-height', 'none', 'important');
  }
  
  const fullscreenMeta = document.getElementById('fullscreenMeta');
  if (fullscreenMeta) fullscreenMeta.textContent = item.meta || '';
  
  const fullscreenLink = document.getElementById('fullscreenLink');
  if (fullscreenLink) fullscreenLink.href = item.link;
  
  // Устанавливаем первое изображение
  console.log('Устанавливаем первое изображение:', item.images[0]);
  setFullscreenMain(item.images[0], true);
  
  // Создаем точки-индикаторы
  console.log('Создаем точки для', item.images.length, 'изображений');
  renderFullscreenDots(item.images);
  
  // Открываем полноэкранный просмотр
  const fullscreenViewer = document.getElementById('fullscreenViewer');
  if (fullscreenViewer) {
    // Сбрасываем состояние - всегда открываем с интерфейсом
    fullscreenViewer.classList.remove('expanded');
    fullscreenViewer.classList.add('open');
    
    // Сбрасываем иконку кнопки расширения
    const fullscreenExpandBtn = document.getElementById('fullscreenExpandBtn');
    if (fullscreenExpandBtn) {
      fullscreenExpandBtn.innerHTML = `
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
        </svg>
      `;
    }
    
    console.log('Полноэкранный просмотр открыт');
  } else {
    console.error('Элемент fullscreenViewer не найден!');
    // Fallback: открываем десктопную модалку
    console.log('Fallback: открываем десктопную модалку');
    openDesktopModal(item, section);
  }
  
  document.body.style.overflow = 'hidden';
  
  // Добавляем обработчики для полноэкранного просмотра
  addFullscreenHandlers();
}
function closeModal(){
  // Мгновенно убираем все классы анимации
  $modal.classList.remove('open', 'swipe-complete', 'swiping');
  document.body.style.overflow='';
  leaveZoom();
  moved=false; // Дополнительный сброс moved при закрытии
  removeSwipeHandlers(); // Удаляем обработчики свайпов при закрытии модалки
  
  // Сбрасываем анимацию модального окна мгновенно
  if (sheetElement) {
    sheetElement.style.transform = '';
    sheetElement.style.transition = 'none';
    sheetElement.classList.remove('swipe-complete', 'wobble');
  }
  
  // Удаляем точки-индикаторы при закрытии модалки
  const dots = document.querySelector('.image-dots');
  if (dots) dots.remove();
}
if($modal) $modal.addEventListener('click',closeModal);
const closeBtn = document.getElementById('closeBtn');
if(closeBtn) closeBtn.addEventListener('click',closeModal);

function renderThumbs(arr){
  $thumbs.innerHTML='';
  
  // Добавляем точки-индикаторы для мобильных устройств
  if (window.innerWidth <= 768 && arr.length > 1) {
    const dotsContainer = document.createElement('div');
    dotsContainer.className = 'image-dots';
    arr.forEach((_, idx) => {
      const dot = document.createElement('div');
      dot.className = `image-dot ${idx === curIndex ? 'active' : ''}`;
      
      // Добавляем обработчик клика для каждой точки
      dot.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        console.log('Клик по точке в модалке:', idx);
        
        if (curIndex !== idx) {
          curIndex = idx;
          setMain(arr[idx], true);
          updateModalDots();
        }
      });
      
      dotsContainer.appendChild(dot);
    });
    $viewer.appendChild(dotsContainer);
  }
  
  arr.forEach((src,i)=>{
    const t=document.createElement('img');
    setSrcWithFallback(t, src, currentHints); t.alt='';
    t.draggable=false;
    t.addEventListener('dragstart', e=>e.preventDefault());
    if(i===curIndex)t.classList.add('active');
    t.onclick=()=>{
      curIndex=i;
      setMain(src, true);
      // Обновляем точки
      document.querySelectorAll('.image-dot').forEach((dot, idx) => {
        dot.classList.toggle('active', idx === i);
      });
    };
    $thumbs.appendChild(t);
  });
}

/* === МГНОВЕННАЯ смена кадра, без интерполяции === */
function setMain(src, snap=false){
  if(!$viewerImg || !$thumbs) return;
  leaveZoom();                 // сброс трансформаций
  if (snap) $viewerImg.style.transition = 'none'; // гарантированно без анимации
  setSrcWithFallback($viewerImg, src, currentHints);
  
  // Адаптивное отображение для мобильных устройств
  if (window.innerWidth <= 768) {
    $viewerImg.onload = function() {
      const isVertical = this.naturalHeight > this.naturalWidth;
      if (isVertical) {
        // Вертикальное фото - по ширине экрана
        this.style.width = '100%';
        this.style.height = 'auto';
        this.style.maxHeight = 'none';
        this.style.objectFit = 'cover';
      } else {
        // Горизонтальное фото - по высоте с сохранением пропорций
        this.style.width = 'auto';
        this.style.height = '100%';
        this.style.maxWidth = '100%';
        this.style.objectFit = 'contain';
      }
    };
  }
  
  // активный превью
  [...$thumbs.children].forEach((el,i)=>el.classList.toggle('active',i===curIndex));
  
  // Обновляем точки-индикаторы
  document.querySelectorAll('.image-dot').forEach((dot, idx) => {
    dot.classList.toggle('active', idx === curIndex);
  });
}

/* Листание по клику по краям — работает ТОЛЬКО когда НЕ зум */
if($viewer) {
  $viewer.addEventListener('click',e=>{
    console.log('Клик по viewer, zoomed:', zoomed);
    if(zoomed) return; // в зуме клики игнорим
    const rect=$viewer.getBoundingClientRect();
    const left=(e.clientX-rect.left) < rect.width/2;
    console.log('Клик по viewer:', left ? 'левой' : 'правой', 'стороне');
    curIndex=(curIndex+(left?-1:1)+current.images.length)%current.images.length;
    console.log('Новый индекс из viewer:', curIndex);
    setMain(current.images[curIndex], true);
    
    // Обновляем точки при клике по краям
    document.querySelectorAll('.image-dot').forEach((dot, idx) => {
      dot.classList.toggle('active', idx === curIndex);
    });
  });
}

/* === ЗУМ ===
   — Кнопка 🔍: включает/выключает
   — Двойной клик по изображению: включает/выключает
   — Перетаскивание: только при нажатой кнопке, без «wobbling» и без drag ghost
*/
if($zoomBtn) {
  console.log('Кнопка зума найдена, добавляем обработчик');
  $zoomBtn.addEventListener('click',(e)=>{
    console.log('Клик по кнопке зума, zoomed:', zoomed);
    e.preventDefault();
    e.stopPropagation();
    if(zoomed) {
      console.log('Выходим из зума');
      leaveZoom();
    } else {
      console.log('Входим в зум');
      enterZoom();
    }
  });
} else {
  console.log('Кнопка зума НЕ найдена!');
}
if($viewerImg) {
  $viewerImg.addEventListener('dblclick', (e)=>{
    e.preventDefault();
    e.stopPropagation();
    if(zoomed) leaveZoom(); // вход только через кнопку; dblclick — только выход
  });
  
  // Добавляем обработчик клика на изображение для листания
  $viewerImg.addEventListener('click', (e)=>{
    console.log('Клик по изображению, zoomed:', zoomed);
    if(zoomed) return; // в зуме клики игнорим
    e.preventDefault();
    e.stopPropagation();
    
    const rect = $viewerImg.getBoundingClientRect();
    const left = (e.clientX - rect.left) < rect.width / 2;
    console.log('Клик по', left ? 'левой' : 'правой', 'стороне');
    curIndex = (curIndex + (left ? -1 : 1) + current.images.length) % current.images.length;
    console.log('Новый индекс:', curIndex);
    setMain(current.images[curIndex], true);
    
    // Обновляем точки при клике по краям
    document.querySelectorAll('.image-dot').forEach((dot, idx) => {
      dot.classList.toggle('active', idx === curIndex);
    });
  });
}

function enterZoom(){
  if(!$viewerImg) return;
  zoomed=true;tx=ty=0;
  $viewerImg.style.transition='none';
  $viewerImg.style.transform=`translate(0px,0px) scale(${SCALE})`;
  $viewerImg.style.cursor='grab';
}
function leaveZoom(){
  if(!$viewerImg) return;
  zoomed=false;dragging=false;moved=false;tx=ty=0;
  $viewerImg.style.transition='none';
  $viewerImg.style.transform='translate(0px,0px) scale(1)';
  $viewerImg.style.cursor='default';
  // Сбрасываем флаг moved при выходе из зума
  moved = false;
}

/* ——— Перетаскивание через Pointer Events (чтоб без ghost-иконок) ——— */
if($viewerImg) {
  $viewerImg.addEventListener('dragstart', e=>e.preventDefault());

  $viewerImg.addEventListener('pointerdown', e=>{
    if(!zoomed) return;
    e.preventDefault(); // не даём браузеру начинать drag-image
    $viewerImg.setPointerCapture(e.pointerId);
    dragging=true; moved=false;
    startX=e.clientX; startY=e.clientY;
    $viewerImg.style.cursor='grabbing';
  });

  $viewerImg.addEventListener('pointermove', e=>{
    if(!zoomed || !dragging) return;
    const dx=e.clientX-startX, dy=e.clientY-startY;
    if (!moved && (Math.abs(dx)>DRAG_THRESHOLD || Math.abs(dy)>DRAG_THRESHOLD)) moved=true;

    const nextX=tx+dx, nextY=ty+dy;
    const bounds=getBounds();
    const clampedX=Math.max(bounds.minX, Math.min(bounds.maxX, nextX));
    const clampedY=Math.max(bounds.minY, Math.min(bounds.maxY, nextY));
    $viewerImg.style.transform=`translate(${clampedX}px,${clampedY}px) scale(${SCALE})`;
  });

  $viewerImg.addEventListener('pointerup', e=>{
    if(!zoomed) return;
    $viewerImg.releasePointerCapture(e.pointerId);
    dragging=false;
    // фиксируем текущее смещение из transform:
    const m = /translate\(([-\d.]+)px,\s*([-\d.]+)px\)/.exec($viewerImg.style.transform);
    if(m){ tx=parseFloat(m[1]); ty=parseFloat(m[2]); }
    $viewerImg.style.cursor='grab';
  });
}

/* Границы для перетягивания в зуме */
function getBounds(){
  if(!$viewerImg || !$viewer) return {minX:0, maxX:0, minY:0, maxY:0};
  const iw=$viewerImg.naturalWidth, ih=$viewerImg.naturalHeight;
  const cw=$viewer.clientWidth, ch=$viewer.clientHeight;
  // размеры вписанной картинки при scale=1
  const imgAspect=iw/ih, boxAspect=cw/ch;
  let fittedW, fittedH;
  if(imgAspect>boxAspect){ fittedW=cw; fittedH=cw/imgAspect; }
  else { fittedH=ch; fittedW=ch*imgAspect; }

  const zw = fittedW * SCALE;
  const zh = fittedH * SCALE;
  const maxX = Math.max(0, (zw - cw)/2);
  const maxY = Math.max(0, (zh - ch)/2);
  return {minX:-maxX, maxX, minY:-maxY, maxY};
}

window.addEventListener('keydown',e=>{ 
  if(e.key==='Escape') {
    // Закрываем полноэкранный просмотр, если он открыт
    const fullscreenViewer = document.getElementById('fullscreenViewer');
    if (fullscreenViewer && fullscreenViewer.classList.contains('open')) {
      closeFullscreenViewer();
    } else {
      closeModal();
    }
  }
});

// Кэш для уже найденных путей к изображениям
const RESOLVED_SRC = Object.create(null);

// Построение списка кандидатов путей с учётом возможной подпапки
function folderHintsFromFirst(first){
  if(!first) return [];
  let s = String(first).trim();
  const low = s.toLowerCase();
  // если автор явно указал подпуть "folder/file.jpg" — используем его как хинт
  if (s.includes('/')) {
    const dir = s.split('/')[0].replace(/^\.\/?|^img\//,'');
    return [dir];
  }
  // иначе строим подсказки из имени первого файла
  if (low.startsWith('img/')) s = s.slice(4);
  const dot = s.lastIndexOf('.');
  const base = dot > 0 ? s.slice(0, dot) : s; // напр. shawl-1
  const lastDash = base.lastIndexOf('-');
  const prefix   = lastDash > 0 ? base.slice(0, lastDash) : base; // shawl
  // вставляем дефис перед хвостовыми цифрами, если его не было (apron1 -> apron-1)
  let dashedPrefix = prefix;
  let i = prefix.length - 1;
  while (i >= 0) { const code = prefix.charCodeAt(i); if (code < 48 || code > 57) break; i--; }
  if (i < prefix.length - 1 && prefix[i] !== '-') {
    dashedPrefix = prefix.slice(0, i + 1) + '-' + prefix.slice(i + 1);
  }
  return Array.from(new Set([dashedPrefix, prefix, base].filter(Boolean)));
}

// Делает несколько вариантов пути и подставляет первый удачный.
function candidatesFor(src, hintFolders){
  if(!src) return ['img/item-placeholder.jpg'];
  let s = String(src);
  const low = s.toLowerCase();
  // абсолютные URL — как есть
  if (low.startsWith('http://') || low.startsWith('https://')) return [s];
  // убрать возможный префикс img/
  if (low.startsWith('img/')) s = s.slice(4);
  else if (low.startsWith('./img/')) s = s.slice(6);
  else if (low.startsWith('/img/')) s = s.slice(5);
  // если уже указан подпуть вида folder/file.jpg — пробуем как есть (с префиксом img/)
  if (s.includes('/')) return ['img/' + s];

  // имя файла без расширения
  const dot = s.lastIndexOf('.');
  const base = dot > 0 ? s.slice(0, dot) : s;            // напр. apron1-1
  const lastDash = base.lastIndexOf('-');
  const prefix   = lastDash > 0 ? base.slice(0, lastDash) : base; // напр. apron1

  // добавить дефис перед хвостовыми цифрами: apron1 -> apron-1
  let dashedPrefix = prefix;
  let i = prefix.length - 1;
  while (i >= 0) { const code = prefix.charCodeAt(i); if (code < 48 || code > 57) break; i--; }
  if (i < prefix.length - 1 && prefix[i] !== '-') {
    dashedPrefix = prefix.slice(0, i + 1) + '-' + prefix.slice(i + 1);
  }

  // Подсказки подпапок: сначала более короткие (shawl-2 раньше shawl-2-1)
  const hints = Array.isArray(hintFolders)
    ? Array.from(new Set(hintFolders)).sort((a,b)=>{
        const ad = a.includes('-'), bd = b.includes('-');
        if(ad && !bd) return -1; // папки с дефисом приоритетнее
        if(bd && !ad) return 1;
        return a.length - b.length; // затем по длине — короткие раньше
      })
    : [];

  const list = [
    // 0) приоритет — папки из подсказок (от коротких к длинным)
    ...hints.map(h => `img/${h}/${s}`),
    // 1) папка = часть до последнего дефиса (belt-skirt-1/belt-skirt-1-1.jpg)
    `img/${prefix}/${s}`,
    // 2) часть + дефис перед цифрами (apron-1/apron1-1.jpg)
    `img/${dashedPrefix}/${s}`,
    // 3) папка = полное имя без расширения (shawl-1/shawl-1.jpg)
    `img/${base}/${s}`,
    // 4) корень img
    `img/${s}`
  ];
  return Array.from(new Set(list));
}

function setSrcWithFallback(img, src, hintFolders){
  // Очищаем предыдущие обработчики
  img.onerror = null;
  img.onload = null;
  
  // Быстрый путь: уже знаем рабочий URL
  if (RESOLVED_SRC[src]) {
    img.src = RESOLVED_SRC[src];
    return;
  }

  // Простая логика - используем точный путь из JSON
  let finalSrc = src;
  
  // Если путь не абсолютный, добавляем префикс img/
  if (src && !src.startsWith('http://') && !src.startsWith('https://')) {
    if (!src.startsWith('img/')) {
      finalSrc = 'img/' + src;
    }
  }

  // Устанавливаем обработчики
  img.onload = function() { 
    RESOLVED_SRC[src] = img.currentSrc || img.src; 
    img.onload = null;
    img.onerror = null;
  };
  
  img.onerror = function() {
    // При ошибке загрузки показываем placeholder
    img.src = 'img/item-placeholder.jpg';
    img.onload = null;
    img.onerror = null;
  };
  
  // Загружаем изображение
  img.src = finalSrc;
}

// Функция для установки баннера в зависимости от вкладки
function setHero(tab){
  if(!$hero) return;
  const next = (tab==='home') ? 'img/bannerh.jpg' : 'img/banner.jpg';
  // первый показ — слушаем load ДО установки src, чтобы не пропустить кешированный ответ
  if(!heroReady){
    const onFirstLoad = ()=>{
      $hero.style.visibility='visible';
      $hero.style.opacity='1';
      $hero.style.transform='translateX(0)';
      heroReady = true;
      $hero.removeEventListener('load', onFirstLoad);
    };
    $hero.addEventListener('load', onFirstLoad);
    if($hero.getAttribute('src')!==next) $hero.src = next;
    return;
  }
  if($hero.getAttribute('src')===next) return;

  const handleTransitionEnd = (e)=>{
    if(e.propertyName!=='opacity') return;
    $hero.removeEventListener('transitionend', handleTransitionEnd);
    const onLoad = () => {
      requestAnimationFrame(()=>{
        $hero.style.opacity='1';
        $hero.style.transform='translateX(0)';
      });
      $hero.removeEventListener('load', onLoad);
    };
    $hero.addEventListener('load', onLoad);
    $hero.src = next;
  };

  $hero.addEventListener('transitionend', handleTransitionEnd, {once:true});
  requestAnimationFrame(()=>{
    $hero.style.opacity='0';
    $hero.style.transform='translateX(-6px)';
  });
}

// Функция для рендера коллекции товаров
function renderCollection(arr, instant=false){
  if(!$catalog) return;
  console.log('renderCollection вызвана, товаров в массиве:', arr.length);
  
  const src = arr.filter(it => {
    const isNotPlaceholder = !it.placeholder;
    const matchesFilter = activeFilter==='all' ? true : (it.status||'stock')===activeFilter;
    console.log(`Товар ${it.title}: placeholder=${it.placeholder}, status=${it.status}, matchesFilter=${matchesFilter}`);
    return isNotPlaceholder && matchesFilter;
  }).sort((a, b) => (a.order || 999) - (b.order || 999));
  
  console.log('Отфильтровано товаров:', src.length, 'активный фильтр:', activeFilter);
  console.log('Отфильтрованные товары:', src.map(item => `${item.title} (${item.status})`));

  closeModal();
  
  // Добавляем плавные переходы для устранения мерцания
  if(!instant){ 
    $catalog.style.transition = 'opacity 0.4s ease-out, transform 0.4s ease-out';
    $catalog.style.opacity='0'; 
    $catalog.style.visibility='hidden';
    $catalog.style.transform = 'translateY(10px)'; // Небольшое смещение для более плавного эффекта
  }
  $catalog.innerHTML='';

  const realCount = (activeFilter==='all')
    ? arr.filter(it=>!it.placeholder).length
    : arr.filter(it=>!it.placeholder && (it.status||'stock')===activeFilter).length;

  if(realCount===0){
    const empty=document.createElement('div');
    empty.className='empty';
    empty.textContent='По выбранному фильтру пока ничего нет';
    $catalog.appendChild(empty);
  }

  src.forEach(it=>{
    const hints = folderHintsFromFirst(it.images[0]);
    const card=document.createElement('div');
    card.className='card'+(it.placeholder?' placeholder':'');
    const imgBox=document.createElement('div');imgBox.className='card-img';
    const img=document.createElement('img');
    setSrcWithFallback(img, it.images[0], hints); img.alt=it.title; img.draggable=false;
    img.addEventListener('dragstart', e=>e.preventDefault());
    imgBox.appendChild(img);
    card.appendChild(imgBox);
    const h3=document.createElement('h3');h3.textContent=it.title;card.appendChild(h3);
    // Форматируем цену для каталога
    const priceText = it.price.replace(' р.', '').replace('р', '');
    const formattedPrice = priceText.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ' ') + ' ₽';
    const price=document.createElement('div');price.className='price';price.textContent=formattedPrice;card.appendChild(price);
    if(!it.placeholder && it.status){ 
      const st=document.createElement('div'); 
      const cls=(it.status==='preorder')?'pre':'in'; 
      st.className='status '+cls; 
      st.textContent=(it.status==='preorder')?'под заказ':'в наличии';
      // Добавляем стили для статуса в карточках
      st.style.padding = '2px 6px';
      st.style.borderRadius = '4px';
      st.style.fontSize = '12px';
      st.style.fontWeight = '500';
      st.style.color = (it.status==='preorder') ? '#92400e' : '#065f46';
      st.style.backgroundColor = (it.status==='preorder') ? '#fef3c7' : '#f0fdf4';
      st.style.opacity = '0.8';
      st.style.border = 'none';
      card.appendChild(st);
    } 
    $catalog.appendChild(card);

    if(!it.placeholder){
      // Добавляем обработчики для переключения изображений при наведении курсора
      let isHovering = false;
      let hoverRaf = 0;
      let currentHoverIndex = 0;
      
      const applyIdx = (idx) => {
        if (idx !== currentHoverIndex && idx < it.images.length) {
          currentHoverIndex = idx;
          setSrcWithFallback(img, it.images[idx], folderHintsFromFirst(it.images[idx]));
        }
      };
      
      imgBox.addEventListener('mouseenter', () => {
        isHovering = true;
      });
      
      imgBox.addEventListener('mousemove', e => {
        if (!isHovering) return;
        
        if (hoverRaf) {
          cancelAnimationFrame(hoverRaf);
        }
        
        hoverRaf = requestAnimationFrame(() => {
          hoverRaf = 0;
          const rect = imgBox.getBoundingClientRect();
          const ratio = (e.clientX - rect.left) / rect.width;
          const idx = Math.min(it.images.length - 1, Math.max(0, Math.floor(ratio * it.images.length)));
          if (idx !== currentHoverIndex) {
            applyIdx(idx);
          }
        });
      });
      
      imgBox.addEventListener('mouseover', () => {
        isHovering = true;
      });
      
      imgBox.addEventListener('mouseout', () => {
        isHovering = false;
        if (hoverRaf) {
          cancelAnimationFrame(hoverRaf);
          hoverRaf = 0;
        }
        if (currentHoverIndex !== 0) {
          applyIdx(0);
        }
      });
      
      imgBox.addEventListener('mouseleave', () => {
        isHovering = false;
        if (hoverRaf) {
          cancelAnimationFrame(hoverRaf);
          hoverRaf = 0;
        }
        if (currentHoverIndex !== 0) {
          applyIdx(0);
        }
      });
      
      card.addEventListener('click', (e) => {
        console.log('Клик по карточке:', it.title, 'вкладка:', currentTab);
        e.stopPropagation();
        openModal(it, currentTab);
      });
    }
  });
  
  console.log('Каталог отрендерен, карточек создано:', src.length);
  
  // Принудительно проверяем, что все карточки добавлены
  const actualCards = $catalog.querySelectorAll('.card');
  console.log('Фактически добавлено карточек в DOM:', actualCards.length);
  
  if (actualCards.length !== src.length) {
    console.error('ОШИБКА: Количество карточек в DOM не совпадает с ожидаемым!');
  }
  

  

}

// Функция для рендера активной вкладки
function renderActive(instant=false){
  if(!$catalog) return;
  const arr = (currentTab === 'home') ? items.filter(item => item.section === 'home') : items.filter(item => item.section === 'nessffo');
  console.log('renderActive вызвана:', {currentTab, itemsCount: items.length, filteredCount: arr.length});
  console.log('Товары в секции', currentTab, ':', arr.map(item => `${item.title} (${item.status})`));
  
  // Управляем кнопкой и панелью руководства
  const $careBtn = document.getElementById('careBtn');
  const showInNessffo = currentTab === 'nessffo';
  
  // Устанавливаем data-section для правильных стилей фильтров
  document.body.setAttribute('data-section', currentTab);
  
  if($careBtn){
    $careBtn.style.display = showInNessffo ? 'flex' : 'none';
  }
  
  if($carePanel){
    // Определяем, мобильное ли устройство
    const isMobile = window.innerWidth <= 768;
    
    if(showInNessffo){
      if(isMobile){
        // На мобильных показываем памятку автоматически
        $carePanel.style.display = 'block';
      } else {
        // На десктопе скрываем, показываем только по клику на кнопку
        $carePanel.style.display = 'none';
      }
    } else {
      // В разделе home скрываем везде
      $carePanel.style.display = 'none';
    }
    
    // Добавляем обработчик клика для кнопки (только на десктопе)
    if(showInNessffo && !isMobile && $careBtn && !$careBtn.hasAttribute('data-click-added')){
      $careBtn.setAttribute('data-click-added', 'true');
      $careBtn.addEventListener('click', function() {
        $carePanel.style.display = $carePanel.style.display === 'none' ? 'block' : 'none';
        $carePanel.classList.remove('collapsed');
      });
    }
    
    // Добавляем обработчик клика для сворачивания памятки
    if(showInNessffo && !$carePanel.hasAttribute('data-click-added')){
      $carePanel.setAttribute('data-click-added', 'true');
      $carePanel.addEventListener('click', function(e) {
        // Сворачиваем/разворачиваем при клике на заголовок или саму панель, но не на элементы списка
        if(e.target.tagName === 'H4' || e.target.closest('h4') || (e.target === this && !e.target.closest('ul')) ){
          $carePanel.classList.toggle('collapsed');
        }
      });
    }
  }
  
  renderCollection(arr, instant);
  // показать сетку (если до этого был скелетон)
  $catalog.style.display = 'grid';
  // Не перезаписываем visibility и opacity, если это не instant рендер
  if(instant) {
    $catalog.style.visibility = 'visible';
    $catalog.style.opacity = '1';
  }
  // обновить баннер для вкладки
  setHero(currentTab);
}

// Инициализация вкладок и фильтров
(function tabs(){
  const tabs=document.querySelectorAll('.topnav .tab');
  const filterBtns = document.querySelectorAll('#filters .fbtn');
  const filterByTab = { home: 'all', nessffo: 'all' }; // дефолт на вкладку

  function setFilter(f){
    console.log('setFilter вызвана с фильтром:', f);
    activeFilter=f;
    filterByTab[currentTab]=f;
    filterBtns.forEach(b=>b.classList.toggle('active', b.dataset.filter===f));
    console.log('Фильтр установлен:', activeFilter);
  }

  function activate(tab){
    console.log('activate вызвана с вкладкой:', tab);
    tabs.forEach(b=>b.classList.toggle('active', b.dataset.tab===tab));
    console.log('Вкладка активирована:', tab);
  }

  // Обработчики для вкладок
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      console.log('Клик по вкладке:', tab.dataset.tab);
      if(tab.classList.contains('active')) {
        console.log('Вкладка уже активна, пропускаем');
        return;
      }
      currentTab = tab.dataset.tab;
      console.log('Переключаемся на вкладку:', currentTab);
      activate(currentTab);
      setFilter(filterByTab[currentTab]);
      renderActive(true);
    });
  });

  // Обработчики для фильтров
  filterBtns.forEach(btn => {
    btn.addEventListener('click', () => {
      console.log('Клик по фильтру:', btn.dataset.filter);
      if(btn.classList.contains('active')) {
        console.log('Фильтр уже активен, пропускаем');
        return;
      }
      setFilter(btn.dataset.filter);
      renderActive(true);
    });
  });

  // Инициализация
  activate(currentTab);
  setFilter(filterByTab[currentTab]);
  console.log('Инициализация завершена: вкладка=', currentTab, 'фильтр=', filterByTab[currentTab]);
  renderActive(true);
})();

// Инициализация каталога при загрузке страницы
document.addEventListener('DOMContentLoaded', function() {
  console.log('DOM загружен, товаров в массиве:', items.length);
  console.log('Каталог найден:', !!$catalog);
  
  // Проверяем наличие элементов полноэкранного просмотра
  console.log('fullscreenViewer найден:', !!document.getElementById('fullscreenViewer'));
  console.log('fullscreenTitle найден:', !!document.getElementById('fullscreenTitle'));
  console.log('fullscreenImg найден:', !!document.getElementById('fullscreenImg'));
  
  if($catalog) {
    console.log('Настройка каталога...');
    // Принудительно показываем каталог
    $catalog.style.display = 'grid';
    $catalog.style.visibility = 'visible';
    $catalog.style.opacity = '1';

    

    
    // Принудительно вызываем рендер
    console.log('Вызов renderActive...');
    renderActive(true);
    console.log('Каталог после рендера:', $catalog.innerHTML.length, 'символов');
    
    // Дополнительная проверка через секунду
    setTimeout(() => {
      if($catalog.innerHTML.length === 0) {
        console.error('Каталог пустой после рендера!');
        console.log('Принудительно перерендерим...');
        renderActive(true);
      }
    }, 1000);
  } else {
    console.error('Каталог не найден!');
  }
});

// Дополнительная инициализация после полной загрузки страницы
window.addEventListener('load', function() {
  console.log('Страница полностью загружена');
  if($catalog && $catalog.innerHTML.length === 0) {
    console.log('Каталог пустой, перерендерим...');
    renderActive(true);
  }
});

// Обновлено: Thu Aug 14 00:24:51 MSK 2025

// Функции для полноэкранного просмотра
function setFullscreenMain(src, animate = false) {
  const fullscreenImg = document.getElementById('fullscreenImg');
  if (!fullscreenImg) {
    console.log('Элемент fullscreenImg не найден');
    return;
  }
  
  console.log('Загружаем изображение:', src, 'анимация:', animate, 'curIndex:', curIndex);
  
  // Проверяем, что src не пустой
  if (!src) {
    console.error('Пустой путь к изображению');
    return;
  }
  
  setSrcWithFallback(fullscreenImg, src, currentHints);
  fullscreenImg.alt = '';
  
  // Фото от самого верха экрана без черного
  fullscreenImg.style.objectFit = 'cover';
  fullscreenImg.style.objectPosition = 'center top';
  
  if (animate) {
    // Простое переключение без анимации
    fullscreenImg.style.transition = 'none';
    fullscreenImg.style.opacity = '1';
  }
  
  // Добавляем обработчик загрузки изображения
  fullscreenImg.onload = () => {
    console.log('Изображение успешно загружено:', src);
  };
  
  fullscreenImg.onerror = () => {
    console.error('Ошибка загрузки изображения:', src);
  };
}

function renderFullscreenDots(images) {
  const dotsContainer = document.getElementById('fullscreenDots');
  if (!dotsContainer) {
    console.log('Контейнер точек не найден');
    return;
  }
  
  // Очищаем контейнер
  dotsContainer.innerHTML = '';
  
  // Создаем точки только если изображений больше одного
  if (images && images.length > 1) {
    console.log('Создаем точки для', images.length, 'изображений');
    
    images.forEach((imagePath, idx) => {
      const dot = document.createElement('button');
      dot.className = `fullscreen-dot ${idx === curIndex ? 'active' : ''}`;
      dot.setAttribute('data-index', idx);
      dot.setAttribute('aria-label', `Изображение ${idx + 1} из ${images.length}`);
      
      // Добавляем обработчик клика
      dot.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        console.log('Клик по точке:', idx, 'изображение:', imagePath);
        
        if (curIndex !== idx) {
          curIndex = idx;
          setFullscreenMain(imagePath, true);
          updateFullscreenDots();
        }
      });
      
      dotsContainer.appendChild(dot);
    });
    
    console.log('Создано точек:', images.length, 'для изображений:', images);
  } else {
    console.log('Точки не нужны - изображений:', images ? images.length : 0);
  }
}

function updateFullscreenDots() {
  const dots = document.querySelectorAll('.fullscreen-dot');
  if (!dots.length) {
    console.log('Точки не найдены для обновления');
    return;
  }
  
  console.log('Обновляем точки, текущий индекс:', curIndex, 'всего точек:', dots.length);
  
  dots.forEach((dot, idx) => {
    const dataIndex = parseInt(dot.getAttribute('data-index'));
    
    if (dataIndex === curIndex) {
      dot.classList.add('active');
      console.log('Активирована точка:', dataIndex);
    } else {
      dot.classList.remove('active');
    }
  });
  
  console.log('Обновлены точки, активная:', curIndex, 'всего точек:', dots.length);
}

function updateModalDots() {
  const dots = document.querySelectorAll('.image-dot');
  if (!dots.length) {
    console.log('Точки модалки не найдены для обновления');
    return;
  }
  
  console.log('Обновляем точки модалки, текущий индекс:', curIndex, 'всего точек:', dots.length);
  
  dots.forEach((dot, idx) => {
    if (idx === curIndex) {
      dot.classList.add('active');
      console.log('Активирована точка модалки:', idx);
    } else {
      dot.classList.remove('active');
    }
  });
  
  console.log('Обновлены точки модалки, активная:', curIndex, 'всего точек:', dots.length);
}

function addFullscreenHandlers() {
  const fullscreenImg = document.getElementById('fullscreenImg');
  const fullscreenViewer = document.getElementById('fullscreenViewer');
  const fullscreenCloseBtn = document.getElementById('fullscreenCloseBtn');
  const fullscreenExpandBtn = document.getElementById('fullscreenExpandBtn');
  
  // Удаляем старые обработчики перед добавлением новых
  if (fullscreenImg) {
    fullscreenImg.removeEventListener('click', fullscreenImgClickHandler);
    fullscreenImg.addEventListener('click', fullscreenImgClickHandler);
  }
  
  if (fullscreenCloseBtn) {
    fullscreenCloseBtn.removeEventListener('click', closeFullscreenViewer);
    fullscreenCloseBtn.addEventListener('click', closeFullscreenViewer);
  }
  
  if (fullscreenExpandBtn) {
    fullscreenExpandBtn.removeEventListener('click', toggleFullscreenImage);
    fullscreenExpandBtn.addEventListener('click', toggleFullscreenImage);
  }
  
  // Обработчик клика по фону для закрытия
  if (fullscreenViewer) {
    fullscreenViewer.removeEventListener('click', fullscreenViewerClickHandler);
    fullscreenViewer.addEventListener('click', fullscreenViewerClickHandler);
  }
  
  // Добавляем поддержку свайпов для полноэкранного просмотра
  if (fullscreenViewer) {
    fullscreenViewer.removeEventListener('touchstart', fullscreenTouchStartHandler);
    fullscreenViewer.removeEventListener('touchend', fullscreenTouchEndHandler);
    fullscreenViewer.addEventListener('touchstart', fullscreenTouchStartHandler, { passive: true });
    fullscreenViewer.addEventListener('touchend', fullscreenTouchEndHandler, { passive: true });
  }
}

// Выносим обработчики в отдельные функции для предотвращения дублирования
function fullscreenImgClickHandler(e) {
  const rect = e.target.getBoundingClientRect();
  const left = (e.clientX - rect.left) < rect.width / 2;
  curIndex = (curIndex + (left ? -1 : 1) + current.images.length) % current.images.length;
  setFullscreenMain(current.images[curIndex], true);
  updateFullscreenDots();
}

function fullscreenViewerClickHandler(e) {
  if (e.target === e.currentTarget) {
    closeFullscreenViewer();
  }
}

function fullscreenTouchStartHandler(e) {
  if (e.touches.length === 1) {
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
  }
}

function fullscreenTouchEndHandler(e) {
  if (e.changedTouches.length === 1 && current && current.images.length > 1) {
    const touchEndX = e.changedTouches[0].clientX;
    const touchEndY = e.changedTouches[0].clientY;
    
    const deltaX = touchStartX - touchEndX;
    const deltaY = touchStartY - touchEndY;
    
    // Проверяем, что это горизонтальный свайп
    if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 50) {
      if (deltaX > 0) {
        // Свайп влево - следующее изображение
        curIndex = (curIndex + 1) % current.images.length;
      } else {
        // Свайп вправо - предыдущее изображение
        curIndex = (curIndex - 1 + current.images.length) % current.images.length;
      }
      setFullscreenMain(current.images[curIndex], true);
      updateFullscreenDots();
    }
  }
}

function closeFullscreenViewer() {
  const fullscreenViewer = document.getElementById('fullscreenViewer');
  const fullscreenImg = document.getElementById('fullscreenImg');
  const fullscreenExpandBtn = document.getElementById('fullscreenExpandBtn');
  
  if (fullscreenViewer) {
    fullscreenViewer.classList.remove('open');
    // Сбрасываем состояние - всегда показываем интерфейс при закрытии
    fullscreenViewer.classList.remove('expanded');
    document.body.style.overflow = '';
    
    // Сбрасываем иконку кнопки
    if (fullscreenExpandBtn) {
      fullscreenExpandBtn.innerHTML = `
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
        </svg>
      `;
    }
    
    // Сбрасываем стили изображения
    if (fullscreenImg) {
      fullscreenImg.style.objectFit = 'cover';
      fullscreenImg.style.objectPosition = 'center top';
    }
  }
}

function toggleFullscreenImage() {
  const fullscreenImg = document.getElementById('fullscreenImg');
  const fullscreenViewer = document.getElementById('fullscreenViewer');
  const fullscreenExpandBtn = document.getElementById('fullscreenExpandBtn');
  
  if (!fullscreenImg || !fullscreenViewer) {
    console.error('Элементы для полноэкранного режима не найдены');
    return;
  }
  
  const isExpanded = fullscreenViewer.classList.contains('expanded');
  console.log('toggleFullscreenImage, isExpanded:', isExpanded);
  
  if (isExpanded) {
    // Возвращаем к обычному режиму - показываем интерфейс
    fullscreenViewer.classList.remove('expanded');
    fullscreenImg.style.objectFit = 'cover';
    fullscreenImg.style.objectPosition = 'center top';
    fullscreenExpandBtn.innerHTML = `
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
      </svg>
    `;
    console.log('Переключен в обычный режим - интерфейс показан');
  } else {
    // Переходим в полноэкранный режим - скрываем интерфейс
    fullscreenViewer.classList.add('expanded');
    fullscreenImg.style.objectFit = 'cover';
    fullscreenImg.style.objectPosition = 'center top';
    fullscreenExpandBtn.innerHTML = `
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M4 14h6v6M20 10h-6V4M14 10l7-7M3 21l7-7"/>
      </svg>
    `;
    console.log('Переключен в полноэкранный режим - интерфейс скрыт');
  }
}

// Тестовая функция для проверки полноэкранного просмотра
function testFullscreen() {
  console.log('Тестируем полноэкранный просмотр...');
  const testItem = {
    title: 'Тестовый товар',
    price: '1000 р.',
    desc: 'Описание тестового товара',
    meta: 'Состав: 100% хлопок',
    link: 'https://t.me/stub123',
    status: 'stock',
    images: ['product_1/product_1_1.jpg', 'product_1/product_1_2.jpg']
  };
  openFullscreenViewer(testItem, 'home');
}
